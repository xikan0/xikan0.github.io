[{"title":"C语言测试","url":"/2025/10/07/C%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95/","content":"指针指针的概念指针是一种特殊的数据类型，用于表示内存地址，（存放另一个变量的地址的变量）\n内存的基本单位是字节，每个字节由8位二进制位（bit）组成，内存是连续的编址空间，每一个字节有唯一的地址标识\n\n指针是无符号整数\n指针的运算不同于整型\n变量定义后，该变量的地址是指针常量\n完整的指针类型包括基类型\n\n指针与整数的区别：从形式上看，地址（指针）是整数，但指针是无符号整数，其表示范围由系统的寻址空间所确定，而不一定与整形相同，操作上，指针运算不同于整形，例如指针能解引用（*）运算\n常使用 %p 格式符来输出十六进制形式的地址\n**指针的基类型：**指定存储对象的类型\n\n例：int *p; 则称int为指针p的基类型，或指针p所指向的变量的类型\n\n指针的声明形式：\nint *p;//和第一种没区别int* p1;//p3是一个指针，p4只是一个int型变量，p6是指针int* p3,p4;int* p5,*p6;//让指针指向一个变量（给指针赋值）int *p=&amp;i;//或者int *p;p=&amp;i;\n\n&amp;的实质（扩展，了解）使用&amp;时，返回的是一个“指向T的指针”类型的常量，即指针常量\n当要给指针赋值，赋一个绝对地址时，通常先将地址写成整形常量的形式，然后强转成相应的类型，如：int*、double*（因为C语言中没有方法去表示指针常量）\n//给指针赋绝对(确定的)地址int *p=(int*)0x12345678;\n\n但一般来说：除了0之外，整数不能赋给指针变量\n\n* 解引用操作符\n*在定义时用来说明一个变量是指针，当使用指针时，*p表示的是p所指向的对象（即i）（对于一个已定义的指针使用 * 操作符，将访问这个指针所指向的对象）\n#include &lt;stdio.h&gt;int main()&#123;    int i;    int *p;    i = 2;    p = &amp;i;\t\t\t/*将i的地址赋给p，即使p指向i*/    printf(&quot;%d&quot;,i);\t\t/*输出i的值*/    printf(&quot;%d&quot;,*p);\t/*输出p所指向的存储单元的值，即i的值*/    return 0;&#125;\n\n\n\n指针变量的初始化一个指针变量未被初始化时，指向的位置不确定，被称为野指针\n**空指针常量：**一个具有0值的整形常量表达式，或者此表达式被强转为void*类型\n例：将 0、 0L、 ‘\\0’、 2-2、 0*5、 (void*)0 赋给任意类型的一个指针，该指针就成为了空指针\n由系统保证空指针不指向任何对象或函数\nC 还定义了一个宏 NULL，用来表示空指针常量\n#define NULL ((void*)0)\n\n对指针进行初始化的几种方式：\n//1.采用NULL或空指针常量int *p = NULL;char *p = 2-2;float *p = 0;//2.取一个对象的地址，然后赋给一个指针int i = 3; int *p = &amp;i;//3.将一个T类型数组的名字赋给一个相同类型的指针char ary[100];char *cp = ary;//4.将一个指针的地址赋给一个指针int i = 3;int *p = &amp;i;int **pp=&amp;p;\t/*其中，*p=i,**pp=i,**pp进行了两次解引用，第一次指向了p,而第二次则是指向了p所指向的i，当只有*pp时，指向的只有存储p这个指针的地址*///5.将一个字符串常量赋给一个字符指针char *cp = &quot;abcdefg&quot;;//6.将一个指针常量赋给一个指针long *p=(long*)0xffffff0;\n\n在C语言中，将一个字符串常量赋给一个字符指针时，字符指针中存储的是字符串常量的首地址。字符串常量在内存中是连续存储的，并且以字符’\\0’结尾，字符指针指向字符串的起始位置\n对指针进行初始化或赋值的实质是将一个地址或同类型（或兼容的类型）的指针赋给它，而不管这个地址是怎么取得的\n对于一个不确定要指向何种类型的指针，定义之后最好初始化为NULL\nvoid* 型指针表示定义了一个指针，但不指定它指向何种类型的数据，有基类型，基类型是 void\nvoid* 型指针作为一种通用的指针，可以和其他任何类型的指针（函数指针除外）相互转化而不需要强转，但无法进行解引用或下标操作\n不能进行解引用的：野指针、空指针、void*型指针\n多级指针（指向指针的指针）常用的是二级指针\nint i = 5000;int *pi = &amp;i;int **ppi=&amp;pi;\n\n\ni  的地址为 108，pi 的内容就是 i 的地址，而 pi 的地址为 104，ppi 的内容即是 pi 的地址。对 ppi 解引用照常会得到 ppi 所指的对象，所获得的对象是指向 int 型变量的指针 pi 。想要真正地访问到 i ，必须对 ppi 进行两次解引用\n常量指针与指针常量（了解）常量指针：指针本身的值不可被改变，int *const a;\n指针常量：一个指针类型的常量，(int*)0x123456ff\n指向const的指针：一个指针它所指向的是一个const对象，const int *p，表明p是一个指向const int 型变量的指针，p自身的值可以被改变，但不能通过对p解引用来改变所指的对象的值\n\n注意：const int 表示“\t指向一个具有const限定符的int类型的指针\t”，即const所修饰的是指针所指向的类型，而非指针\n\n指针与函数函数的局限性：\n\n函数调用只能是单向“传值”的方式，被调用的函数无法访问主调函数中定义的对象\n函数只能返回唯一的函数值\n只能向函数传值，不能“传操作”，即参数不能是函数\n\n指针作函数参数\n变量名作实参时，传递的是变量的值，称为按值调用\n变量的地址作实参，传递的是变量的地址，称为按地址调用\n\n\n易错点：\n1. C语言只有唯一的传参数方式，即单向传值\n传地址也是单向传值，更改形参的值（地址），主调函数里的实参的值（地址）没关系，不过他俩解引用都指向同一个地址，所以可以用来更改同一个变量\n2. 函数只能有一个返回值，但可通过指针来获取函数的多个计算结果\n\n函数指针与指针函数指针函数：本质是一个函数，该函数的返回值是一个指针\n声明格式为：类型标识符 *函数名(参数表)\n\n解析类型声明需要遵循“从右往左”的顺序，先解释代表函数的（参数表），即它是一个函数，再看函数的原型为“类型 *”\n\nint *fun(int x,int y);int * fun(int x,int y)；int* fun(int x,int y);\t//该函数返回的是一个int型的指针，是一个地址\n\n可以将返回值定义为 void* 型，接收时需要强转成自己需要接收的类型\n函数指针：（指针常量）本质是一个指针变量，该指针指向这个函数（就是指向函数的指针）\n声明格式：int (*fun)(int x,int y);\n函数指针需要把一个函数的地址赋给它：（这样就可以解引用这个指针来调用这个函数）\nfun = &amp;Function;fun = Function;\n\n&amp;地址运算符不是必须的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表\n调用函数指针：\nx = (*fun)();x = fun();\t//这两个是一样的\n\n\n\n指针的算数运算指针来访问数组中的元素char ary[100]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;char *cp =ary;\t\t//*cp现在指向了数组的第1个元素char *cp =&amp;ary[3]\t//*cp现在指向了数组的第4个元素/*因为数组名代表该数组的第一个元素地址（元素的起始地址），所以赋变量时不用&amp;，但其他位置的元素就需要了*/\n\n注意：\n\n在C语言中，访问数组元素本质就是间接访问\n访问数组元素p[i]，p不一定是数组名，p是指向该数组内任意一个元素的指针即可，但那样下标的范围就不是0 ~ n-1 了，而是p所指向的那个元素为原点0，左边下标是负数，右边下标是正数\n\n指针+整数 或指针-整数指针 + 整数 &#x3D; 另一个指针\n如：上述的 cp + 1，则产生的指针指向数组中的下一个字符，a[i]==*(a+i)\n当指针相加减时，所做的就是指针加上或减去步长乘以那个整数的积，步长就是指针所指向的类型的大小（即指针移动一个位置时要跳过几个字节）\nint ia[100]=&#123;1,2,3,4,5&#125;;int *ip=ia;ip+=3;/*其中，ip加上3实际进行的操作是ip+4*3，因为ip指向的元素类型为int*/ip++;/*自增、自减后再解引用*/++*p;*++p;\n\n\n注意：\n\n原来的指针和计算后的新指针都需要指向同一个数组的元素、或指向数组数组范围的下一位置时才是合法的\n自增、自减运算符和*取地址运算符、&amp;的优先级相同，且都是按照自右向左方式结合\n\n\n指针 - 指针注意：C标准里，没有定义两个指针相加的运算，所以会报错\n**指针的减法运算是有条件的：**当两个指针指向同一数组、或有一个指针指向该数组末端的下一位置时，两个指针可做减法运算\nint ia[100]=&#123;0,1,2,3,4,5&#125;;int *ip = ia;int 8ig = ia+3;ptrdiff_t n = ig-ip;\t/*ptrdiff_t是一个标准库类型，是一个无符号整数，可为负数*/\n\n\n\n两指针相减，得到的是两指针所指向元素之间的距离，也就是他们相隔几个数组元素，与步长没关系\n指针可以加减0，指针保持不变，空指针也可以加减0，\n两个空指针相减，结果也是0\n\n\n指针的关系运算两指针可进行关系判断：&#x3D;&#x3D;、!&#x3D;、&lt;&#x3D;、&gt;&#x3D;\n判断大小是根据在数组中的相对位置来判断的，如：q[2] &lt;&#x3D; q[4]\n指针与数组数组名数组名代表该数组的第一个元素地址（元素的起始地址），数组名是一个常量指针（常指针），自身的值不能改变\n在对数组名实施*&amp;*操作时，返回的是一个指向数组的指针，而非具有某个指针常量值的指针\n数组和指针的差别：\n\n声明数组时，同时分配了用于容纳数组元素的空间\n声明指针时，只分配了用于容纳指针本身的空间\n\n通过数组名引用元素int last = ia[99];int last = *(ia+99);*&amp;ai[99] \t/*先取ai[99]的地址，再解引用*/\n\n解释：\n\nia是数组名，也就是一个指向首个元素的常量指针：ai[0]\n指针可以加整数，返回一个新的指针，指向该数组内的元素的地址\n*(ai+99)也就是从 ai[0] 开始向后99位，也就是 ai[99]\n数组名是常指针，不能对它的值进行修改。ia + 99是可以的，但ia++是不行的，它的意思是ia &#x3D; ia +1;修改了ia的值\n\n函数形参中的数组一、声明函数形参，数组会被改写成指向数组第一个元素的指针\nvoid array(int *ia)&#123;&#125;\t\tvoid array(int ia[])&#123;&#125;\t\t//ia[] 被转换成 *iavoid array(int ia[100])&#123;&#125;\t//ia[100] 被转换成 *ia\n\n当数组名作为函数形参时，已经被转换成了一般的指针（不是常指针了），因此，这个形参数组名的值可以被改变了。此时，不能通过sizeof运算符获取数组的长度，不能判断数组的长度时，可能会产生数组越界访问。因此传递数组名时，需要一起传递数组的长度。\nvoid array(int ia[100])&#123;    ia++;\t/*这个是合法的*/    int id[100]=&#123;1,2,3,4,5&#125;;    id++;\t/*这个是不合法的*/&#125;\n\nC语言中，所有非数组形式的实参（包括指针）均以值传递的形式调用（形参值的变换不影响实参）\n例如：主函数传了一个指针，给一个函数的形参，形参拿到的指针是原指针的副本，无法影响实参，但都指向一个地址，可以影响地址里的值\n\n二、用 sizeof(形参数组名)，来获得数组的大小时，只能得到一个指针的大小（因为形参数组名只是一个指针了）\n\n32位系统中，指针大小通常为4字节\n64位系统中，指针大小通常为8字节\n\n指向数组的指针(二维数组)指向数组的指针主要用来对二维数组进行操作\n用指针定义二维数组数组指针：标识符类型 (*标识符)[整形常量]\n二维数组名的类型为 数组指针 类型\nint m[50][100];int (*p)[100]=m;\n\n其中，*p 指向的是数组的第一个元素，而后面的 [100] 下标，则表示这一个元素里又有个长度为100的整形数组，(*p)[100] 就代表每个元素都是一个 int[100] 型的数组，通过对 p 的算数运算可以使它指向 m 数组中的任意一个元素，而不需要指导 m 是一个多长的数组， 但一定要知道 m 中每个数组元素的长度\n所以这个二维数组的步长：p + n，也就是 n*100*sizeof(int) 个字节，相当于跳过矩阵中的 n 行，每行都有 100 个 int 型元素\n数组越界的问题：\n对指针的算术运算可以使它指向数组中的任何一个元素包括超出数组范围的第一个元素，这个超出范围的第一个元素实际上是不存在的，这个“元素”的地址在数组所占的内存之后，它是数组的第一个出界点\n这个地址可以赋给指向数组元素的指针，但ANSI C仅允许它进行赋值或比较运算，不能对保存这个地址的指针进行解引用或下标运算。\n#include &lt;stdio.h&gt;int mian()&#123;    int m[2][4] = &#123;        &#123;1,2,3,4&#125;,        &#123;5,6,7,8&#125;    &#125;;    int (*p)[4] = m;        int i = p[1][2];\t//可以通过p[i][j]的形式访问数组内的元素    printf(&quot;%p&quot;,p);\t\t//输出0xffe00    printf(&quot;%p&quot;,p+1);\t//输出0xffe10, 跨了一个数组元素，这个数组的大小：4*4=16，所以十六进制里进一    return 0;&#125;\n\n在表达式中一维数组名会转换为指向数组第一个元素的指针，二维数组也是一样的，所以也会被转换为指向第一个元素的指针，它的第一个元素是一个数组，所以最终的结果就是二维数组名被转换成指向数组的指针\n关于二维数组的数组名：\nint (*p)[100] = m 中，对于 m[n] ，是 m 数组的第 n+1个元素的名字，也就是数组名\n所以可以有  p=&amp;m[n] ，其中p指向了一个数组元素，也就是矩阵中的某一行\nint *column_p = m[n];\n\n当对 m[n] 进行 sizeof 操作时，结果是 100*sizeof(int) ；而 sizeof(m) 结果是50*100*sizeof(int)\n指针数组、数组指针明确运算符优先顺序：() &gt; [] &gt; *\n指针数组例子：int *p[100]\n根据优先级，先看[]，则 p 是一个数组，该数组是一个 int * 型，因此数组的元素是指针类型，共 100 个元素。称为“指针的数组”，即指针数组\n数组指针行指针是一个指向一维数组的指针，它专门用来操作二维数组中的”整行”数据\n例子：int (*p)[100]\n根据优先级，先看括号内，可知 p 是一个指针，这个指针指向一个一维数组，数组长度为 100 。称为“指向数组的指针”，即数组指针\n\n字符串与指针（了解）char *cp = &quot;abcdefg&quot;;中”abcdefg”会被转换为一个没有名字的字符数组，这个数组被 abcdefg 和一个空字符 ‘&#x2F;0’ 初始化，并且会得到一个指针，它的值为第一个字符的地址\nprintf(&quot;%c\\n&quot;,*&quot;abcdefg&quot;);\t\t\t//字符串常量的值是一个指针常量，指向的是字符串的第一个字符，输出aprintf(&quot;%c\\n&quot;, *(&quot;abcdefg&quot;+ 1));\t//对这个指针进行算术运算则其指向下一个字符，再对它解引用输出bprintf(&quot;%c\\n&quot;,&quot;abcdefg&quot;[5]);\t\t//既然&quot;abcdefg&quot;是一个指针，那么&quot;abcdefg&quot;[5]就可以写成*(&quot;abcdefg&quot; + 5)，输出fprintf(&quot;%s&quot;,cp);\t//直接通过该指针访问整个字符串\n\n可以快速初始化字符数组：char ca[]=&quot;abcdefg&quot;;\n两个方法的对比：\nchar ca[]=&quot;abcdefg&quot;;\t//初始化一个字符数组的元素char *cp =&quot;abcdefg&quot;;\t//一个字符串常量\n\n用来初始化字符数组的字符串常量，编译器会在栈中为字符数组分配空间，然后把字符串中的所有字符复制到数组中\n用来初始化字符指针的字符串常量会被编译器安排到只读数据存储区，但也是按字符数组的形式来存储的，可以通过一个字符指针读取字符串常量但不能修改它，否则会发生运行时错误\n不是所有的字符串常量都放在不同的地址\nchar str1[] = &quot;abc&quot;;char str2[] = &quot;abc&quot;;char *str3=&quot;abc&quot;;char *str4=&quot;abc&quot;;printf(&quot;%d\\n&quot;,str1==str2);\t//输出0printf(&quot;%d\\n&quot;,str3==str4);\t//输出1\n\nstr1 和 str2 在栈中各自有不同的空间，而 str3 和 str4 是两个字符指针，分别被初始化为相同字符的字符串常量，二者指向相同的区域\n指针的值传递（了解）#include &lt;stdio.h&gt;void pointer_plus(char**p)&#123;    *p += 3;&#125;int main( )&#123;    char*a = &quot;abcd&quot;;    pointer_plus(&amp;a);    printf(&quot;%c\\n&quot;, *a);    return0;&#125;\n\n\na是一个字符指针，拿到的是字符串常量的第一个字符的地址，（这个地址是常量，但a不是）\n将 a 的存储地址给到函数pointer_plus，将 a 所指向的地址向后推了3位&#x3D;在主函数里a+=3;\n所以可通过传递指针的指针（复制的），来改变原指针所指向的位置（被复制的改了）\n\n动态内存分配定义变量、数组，都是为存储对象静态分配内存\n动态分配和静态分配的区别：\n分配时机：\n静态分配在编译期就确定内存的大小和位置；动态则是在程序运行时根据需要来分配或释放内存\n\n管理方式：\n静态分配由编译器自动管理，程序员无法干预；动态则需要手动管理\n\n\n\nmalloc 和 freeC标准库里用这两个函数来动态分配内存和释放、共同维护一个内存池\n一、malloc函数\n向内存申请一块连续可用的空间，并返回指向块开头的指针\nvoid *malloc(size_t size)\n函数动态分配size字节的内存块，类型size_t是用来表示内存大小的无符号整型，若内存分配失败，则返回NULL；若分配成功，则返回内存块的起始地址（基地址）\nint *p;p = (int *)malloc(sizeof(int)*10);if(p!=NULL)    for(int i=0;i&lt;10;i++)        p[i] = 0;\n\n\n注意：\n\nmalloc的返回值是void*型，强转是不必要的，推荐加上\n分配的内存大小可以用 sizeof（） 乘所需要的类型的个数\n\n\n二、free函数\n动态分配的内存不会自动释放，必须由程序员调用free函数释放\nvoid free(void *ptr)\n\nfree 函数只能释放动态分配的内存块\n如果 ptr 是零指针（空指针），则 free 函数不运行操作\n函数将释放 ptr 指向的内存块\n\ncalloc和realloc一、calloc函数\nvoid* calloc (size_t num,size_t size);\nnum 是要分配的元素个数，size 是每个元素的字节数，它会在内存中分配 num * size 字节的连续空间\nint *p;p = (int *)calloc(5,sizeof(int));\n\n二、realloc函数\nvoid* realloc(void* ptr, size_t size);\n重新分配已经存在的内存的空间大小\nptr 表示要重新分配大小的指针，size 表示重新分配内存的大小，\n\n分配成功返回一个指针，不成功返回NULL\n重新分配的大于原来大小，原来的值会保留\n如果小于原来大小，多于的会被释放掉\n\n","tags":["C语言"]},{"title":"Hello World","url":"/2025/10/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]